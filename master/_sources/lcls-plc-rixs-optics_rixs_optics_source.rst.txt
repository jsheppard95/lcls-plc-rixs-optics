

DUTs
----


GVLs
----


GVL_COM_Buffers
^^^^^^^^^^^^^^^

::

    VAR_GLOBAL
    	// M1K2
    	Serial_RXBuffer_M1K2 : ComBuffer;
    	Serial_TXBuffer_M1K2 : ComBuffer;
    END_VAR


GVL_M1K2
^^^^^^^^

::

    {attribute 'qualified_only'}
    VAR_GLOBAL
    	// Pitch Mechanism:
    	{attribute 'TcLinkTo' := '.diEncCnt:=TIIB[EL5042_M1K2_Pitch]^FB Inputs Channel 1^Position'}
    	M1K2_Pitch : HOMS_PitchMechanism := (ReqPosLimHi := 200,
    		                                 ReqPosLimLo := -30,
    		                                 diEncPosLimHi := 10121210,
    		                                 diEncPosLimLo := 10004610); // Set to 50 urad before hard limits tripped during SAT
    END_VAR


GVL_M1K2_Constants
^^^^^^^^^^^^^^^^^^

::

    {attribute 'qualified_only'}
    VAR_GLOBAL CONSTANT
    	// Encoder reference values in counts = nm
    	// Enc reference values after alignment 3-13-20
    	nYLEFT_ENC_REF : ULINT := 96270560;
    	nYRIGHT_ENC_REF : ULINT := 98728200;
    	nXUP_ENC_REF : ULINT := 19847200;
    	nXDWN_ENC_REF : ULINT := 21007520;
    	
    	// Lever arm for Yright/Yleft -> Roll about Z-axis
    	fRollLeverArm_um : REAL := 717000; // lever arm for Yright/Yleft axes in um
    END_VAR


GVL_SerialIO
^^^^^^^^^^^^

::

    VAR_GLOBAL
    	//Better have your inputs and outputs!
    	// M1K2
    	Serial_stComIn_M1K2   AT %I*	:	EL6inData22B (*KL6inData22B*);
    	Serial_stComOut_M1K2  AT %Q*	:	EL6outData22B (*KL6outData22B*);
    END_VAR


Main
^^^^

::

    VAR_GLOBAL
    (*
        Only includes motor definitions for the IOC
        These are hard-coded to be Main.M#,
        but are very convenient to store in a GVL,
        hence the confusing namespace here

        This should be refactored once the IOC
        supports arbitrary ads paths for motors
    *)
    	(*MR1K2*)
    	// Motors
    	{attribute 'TcLinkTo' := '.bLimitForwardEnable:=TIIB[EL7047_M1K2_Yleft]^STM Status^Status^Digital input 1;
                                  .bLimitBackwardEnable:=TIIB[EL7047_M1K2_Yleft]^STM Status^Status^Digital input 2'}
    	{attribute 'pytmc' := '
    		pv: MR1K2:SWITCH:MMS:YLEFT
    	'}
    	M1 : DUT_MotionStage := (fVelocity:=100.0, nEnableMode:=ENUM_StageEnableMode.ALWAYS); // M1K2 Yup
    	fbMotionStage_m1 : FB_MotionStage;

    	{attribute 'TcLinkTo' := '.bLimitForwardEnable:=TIIB[EL7047_M1K2_Yright]^STM Status^Status^Digital input 1;
                                  .bLimitBackwardEnable:=TIIB[EL7047_M1K2_Yright]^STM Status^Status^Digital input 2'}
    	{attribute 'pytmc' := '
    		pv: MR1K2:SWITCH:MMS:YRIGHT
    	'}
    	M2 : DUT_MotionStage := (fVelocity:=100.0, nEnableMode:=ENUM_StageEnableMode.ALWAYS); // M1K2 Ydwn
    	fbMotionStage_m2 : FB_MotionStage;

    	{attribute 'TcLinkTo' := '.bLimitForwardEnable:=TIIB[EL7047_M1K2_Xup]^STM Status^Status^Digital input 1;
                                  .bLimitBackwardEnable:=TIIB[EL7047_M1K2_Xup]^STM Status^Status^Digital input 2'}
    	{attribute 'pytmc' := '
    		pv: MR1K2:SWITCH:MMS:XUP
    	'}
    	M3 : DUT_MotionStage := (fVelocity:=150.0, nEnableMode:=ENUM_StageEnableMode.ALWAYS); // M1K2 Xup
    	fbMotionStage_m3 : FB_MotionStage;

    	{attribute 'TcLinkTo' := '.bLimitForwardEnable:=TIIB[EL7047_M1K2_Xdwn]^STM Status^Status^Digital input 1;
                                  .bLimitBackwardEnable:=TIIB[EL7047_M1K2_Xdwn]^STM Status^Status^Digital input 2'}
    	{attribute 'pytmc' := '
    		pv: MR1K2:SWITCH:MMS:XDWN
    	'}
    	M4 : DUT_MotionStage := (fVelocity:=150.0, nEnableMode:=ENUM_StageEnableMode.ALWAYS); // M1K2 Xdwn
    	fbMotionStage_m4 : FB_MotionStage;

    	{attribute 'TcLinkTo' := '.bLimitForwardEnable:=TIIB[EL7047_M1K2_PitchCoarse]^STM Status^Status^Digital input 1;
                                  .bLimitBackwardEnable:=TIIB[EL7047_M1K2_PitchCoarse]^STM Status^Status^Digital input 2'}
    	{attribute 'pytmc' := '
    		pv: MR1K2:SWITCH:MMS:PITCH
    	'}
    	M5 : DUT_MotionStage := (fVelocity := 30.0, nEnableMode:=ENUM_StageEnableMode.ALWAYS); // M1K2 Pitch Stepper

    	
    	(*SP1K-Mono*)
    	{attribute 'pytmc' := '
    		pv: SP1K1:MONO:MMS:M_PI
    	'}
    	{attribute 'TcLinkTo' := '.bLimitForwardEnable:=TIIB[m_pi_m]^STM Status^Status^Digital input 1;
                                  .bLimitBackwardEnable:=TIIB[m_pi_m]^STM Status^Status^Digital input 2'}
    	//{attribute 'TcLinkTo' := '.bLimFwd:=TIIB[m_pi_m]^STM Status^Status^Digital input 1;  .bLimBwd:=TIIB[m_pi_m]^STM Status^Status^Digital input 2'}    
    	M6: DUT_MotionStage:=(nEnableMode:=0, bGantryAxis:=FALSE );
    	{attribute 'pytmc' := '
    		pv: SP1K1:MONO:MMS:G_PI
    	'}
    	{attribute 'TcLinkTo' := '.bLimitForwardEnable:=TIIB[g_pi_m]^STM Status^Status^Digital input 1;
                                  .bLimitBackwardEnable:=TIIB[g_pi_m]^STM Status^Status^Digital input 2'}
    	//{attribute 'TcLinkTo' := '.bLimFwd:=TIIB[g_pi_m]^STM Status^Status^Digital input 1;  .bLimBwd:=TIIB[g_pi_m]^STM Status^Status^Digital input 2'}    
    	M7: DUT_MotionStage:=(nEnableMode:=0, bGantryAxis:=FALSE );
    	{attribute 'pytmc' := '
    		pv: SP1K1:MONO:MMS:M_H
    	'}
    	{attribute 'TcLinkTo' := '.bLimitForwardEnable:=TIIB[m_h_m]^STM Status^Status^Digital input 1;
                                  .bLimitBackwardEnable:=TIIB[m_h_m]^STM Status^Status^Digital input 2'}
    	//{attribute 'TcLinkTo' := '.bLimFwd:=TIIB[m_h_m]^STM Status^Status^Digital input 1;  .bLimBwd:=TIIB[m_h_m]^STM Status^Status^Digital input 2'}    
    	M8: DUT_MotionStage:=(nEnableMode:=0, bGantryAxis:=FALSE );
    	{attribute 'pytmc' := '
    		pv: SP1K1:MONO:MMS:G_H
    	'}
    	{attribute 'TcLinkTo' := '.bLimitForwardEnable:=TIIB[g_h_m]^STM Status^Status^Digital input 1;
                                  .bLimitBackwardEnable:=TIIB[g_h_m]^STM Status^Status^Digital input 2'}
    	//{attribute 'TcLinkTo' := '.bLimFwd:=TIIB[g_h_m]^STM Status^Status^Digital input 1;  .bLimBwd:=TIIB[g_h_m]^STM Status^Status^Digital input 2'}    
    	M9: DUT_MotionStage:=(nEnableMode:=0, bGantryAxis:=FALSE);
    	{attribute 'pytmc' := '
    		pv: SP1K1:MONO:MMS:SD_V
    	'}
    	{attribute 'TcLinkTo' := '.bLimitForwardEnable:=TIIB[s_io_m]^STM Status^Status^Digital input 1;
                                  .bLimitBackwardEnable:=TIIB[s_io_m]^STM Status^Status^Digital input 2'}
    	//{attribute 'TcLinkTo' := '.bLimFwd:=TIIB[s_io_m]^STM Status^Status^Digital input 1;  .bLimBwd:=TIIB[s_io_m]^STM Status^Status^Digital input 2'}    
    	M10: DUT_MotionStage:=(nEnableMode:=0, bGantryAxis:=FALSE );
    	{attribute 'pytmc' := '
    		pv: SP1K1:MONO:MMS:SD_ROT
    	'}
    	//no limits on this motion
    //	{attribute 'TcLinkTo' := '.bLimFwd:=TIIB[s_r]^STM Status^Status^Digital input 1;  .bLimBwd:=TIIB[s_r]^STM Status^Status^Digital input 2'}    
    	M11: DUT_MotionStage:=(nEnableMode:=0, bGantryAxis:=FALSE );

    	

    END_VAR


POUs
----


P_Serial_Com
^^^^^^^^^^^^

::

    PROGRAM P_Serial_Com
    VAR
    	fbSerialLineControl_EL6001_M1K2: SerialLineControl;
    END_VAR
    //These are the global IOs...don't forget to copy your data into them

    (* EL6001 Serial port 0 com function *)
    fbSerialLineControl_EL6001_M1K2(Mode:= SERIALLINEMODE_EL6_22B (*SERIALLINEMODE_KL6_22B_STANDARD*),
    						        pComIn:= ADR(Serial_stComIn_M1K2),
    						   	    pComOut:=ADR(Serial_stComOut_M1K2),
    						        SizeComIn:= SIZEOF(Serial_stComIn_M1K2),
    						        TxBuffer:= Serial_TXBuffer_M1K2,
    						        RxBuffer:= Serial_RXBuffer_M1K2,
    						        Error=> ,
    						        ErrorID=> );

    END_PROGRAM


PiezoSerial
^^^^^^^^^^^

::

    PROGRAM PiezoSerial
    VAR
    	//PI Serial
    	fbE621SerialDriver_M1K2 : FB_PI_E621_SerialDriver;
    	rtInitParams_M1K2	:	R_TRIG;
    	tonTimeoutRst_M1K2	: TON := (PT:=T#2S); //For timeout reset
    END_VAR
    //Piezo E-621
    ///////////////////////
    fbE621SerialDriver_M1K2.i_xExecute := TRUE;
    fbE621SerialDriver_M1K2.i_xExecute R= fbE621SerialDriver_M1K2.q_xDone;
    fbE621SerialDriver_M1K2(iq_stPiezoAxis:= GVL_M1K2.M1K2_Pitch.Piezo,
    		                iq_stSerialRXBuffer:= Serial_RXBuffer_M1K2,
    		                iq_stSerialTXBuffer:= Serial_TXBuffer_M1K2);

    END_PROGRAM


PRG_1_PlcTask
^^^^^^^^^^^^^

::

    PROGRAM PRG_1_PlcTask
    VAR

    END_VAR
    PRG_MR1K2();
    //PRG_SP1K1_MONO();

    END_PROGRAM


PRG_MR1K2
^^^^^^^^^

::

    PROGRAM PRG_MR1K2
    VAR
    	{attribute 'TcLinkTo' := '.fbRunHOMS.bSTOEnable1:=TIIB[EL1004_M1K2_STO]^Channel 1^Input;
                                  .fbRunHOMS.bSTOEnable2:=TIIB[EL1004_M1K2_STO]^Channel 2^Input;
    	                          .fbRunHOMS.stYupEnc.Count:=TIIB[EL5042_M1K2_Yleftright]^FB Inputs Channel 1^Position;
    	                          .fbRunHOMS.stYdwnEnc.Count:=TIIB[EL5042_M1K2_Yleftright]^FB Inputs Channel 2^Position;
    	                          .fbRunHOMS.stXupEnc.Count:=TIIB[EL5042_M1K2_Xupdwn]^FB Inputs Channel 1^Position;
    	                          .fbRunHOMS.stXdwnEnc.Count:=TIIB[EL5042_M1K2_Xupdwn]^FB Inputs Channel 2^Position'}
    	{attribute 'pytmc' := '
    		pv: MR1K2:SWITCH
    	'}
    	M1K2 : DUT_HOMS;

    	// Encoder Arrays/RMS Watch:
    	{attribute 'pytmc' := '
    		pv: MR1K2:SWITCH:ENC:Y
    	'}
    	fbYRMSErrorM1K2 : FB_RMSWatch;
    	fMaxYRMSErrorM1K2 : LREAL;
    	fMinYRMSErrorM1K2 : LREAL;

    	{attribute 'pytmc' := '
    		pv: MR1K2:SWITCH:ENC:X
    	'}
    	fbXRMSErrorM1K2 : FB_RMSWatch;
    	fMaxXRMSErrorM1K2 : LREAL;
    	fMinXRMSErrorM1K2 : LREAL;

    	{attribute 'pytmc' := '
    		pv: MR1K2:SWITCH:ENC:PITCH
    	'}
    	fbPitchRMSErrorM1K2 : FB_RMSWatch;
    	fMaxPitchRMSErrorM1K2 : LREAL;
    	fMinPitchRMSErrorM1K2 : LREAL;

    	// Pitch Control
    	fbM1K2PitchControl : FB_PitchControl;
    	bM1K2PitchDone : BOOL;
    	bM1K2PitchBusy : BOOL;

    	// 3-15-20 Having issues with pitch control on new Axilon systems
    	// Using stepper only for now
    	fbMotionStage_m5 : FB_MotionStage;
    	
    	// Roll (Rotation about Z axis) induced from Ygantry:

    	{attribute 'pytmc' := '
    		pv: MR1K2:SWITCH:ENC:ROLL
    		field: EGU urad
    		io: i
    	'}
    	fYRoll_urad : LREAL; // Roll about Z axis in urad
    END_VAR
    // M1K2
    M1K2.fbRunHOMS(stYup:=M1,
                   stYdwn:=M2,
                   stXup:=M3,
                   stXdwn:=M4,
                   stPitch:=M5,
    	           nYupEncRef:=GVL_M1K2_Constants.nYLEFT_ENC_REF,
                   nYdwnEncRef:=GVL_M1K2_Constants.nYRIGHT_ENC_REF,
                   nXupEncRef:=GVL_M1K2_Constants.nXUP_ENC_REF,
                   nXdwnEncRef:=GVL_M1K2_Constants.nXDWN_ENC_REF,
    			   bExecuteCoupleY:=M1K2.bExecuteCoupleY,
                   bExecuteCoupleX:=M1K2.bExecuteCoupleX,
    			   bExecuteDecoupleY:=M1K2.bExecuteDecoupleY,
                   bExecuteDecoupleX:=M1K2.bExecuteDecoupleX,
                   bGantryAlreadyCoupledY=>M1K2.bGantryAlreadyCoupledY,
                   bGantryAlreadyCoupledX=>M1K2.bGantryAlreadyCoupledX,
                   nCurrGantryY=>M1K2.nCurrGantryY,
                   nCurrGantryX=>M1K2.nCurrGantryX);

    // Convert nCurrGantry to um (smaller number) to read out in epics
    M1K2.fCurrGantryY_um := LINT_TO_REAL(M1K2.nCurrGantryY) / 1000.0;
    M1K2.fCurrGantryX_um := LINT_TO_REAL(M1K2.nCurrGantryX) / 1000.0;

    fYRoll_urad := (REAL_TO_LREAL(ATAN(M1K2.fCurrGantryY_um / GVL_M1K2_Constants.fRollLeverArm_um))) * EXPT(10, 6);

    // FB_MotionStage's for non-piezo axes
    fbMotionStage_m1(stMotionStage:=M1);
    fbMotionStage_m2(stMotionStage:=M2);
    fbMotionStage_m3(stMotionStage:=M3);
    fbMotionStage_m4(stMotionStage:=M4);

    // Calculate Pitch RMS Error:
    fbYRMSErrorM1K2(stMotionStage:=M1,
    	            fMaxRMSError=>fMaxYRMSErrorM1K2,
    				fMinRMSError=>fMinYRMSErrorM1K2);

    fbXRMSErrorM1K2(stMotionStage:=M3,
    	            fMaxRMSError=>fMaxXRMSErrorM1K2,
    				fMinRMSError=>fMinXRMSErrorM1K2);

    fbPitchRMSErrorM1K2(stMotionStage:=M5,
    	                fMaxRMSError=>fMaxPitchRMSErrorM1K2,
    					fMinRMSError=>fMinPitchRMSErrorM1K2);

    (*
    // Pitch Control
    fbM1K2PitchControl(Pitch:=GVL_M1K2.M1K2_Pitch,
    				   Stepper:=M5,
    				   lrCurrentSetpoint:=M5.fPosition,
                       q_bDone=>bM1K2PitchDone,
                       q_bBusy=>bM1K2PitchBusy);
    // When STO hit, need to reset SP
    IF NOT M5.bHardwareEnable THEN
    	M5.fPosition := M5.stAxisStatus.fActPosition;
    END_IF
    *)
    // 3-15-20: Having issues with pitch control on new Axilon systems
    fbMotionStage_m5(stMotionStage:=M5);

    END_PROGRAM


PRG_SP1K1_MONO
^^^^^^^^^^^^^^

::

    PROGRAM PRG_SP1K1_MONO
    VAR
    	
    	// Where is the STO
    	{attribute 'TcLinkTo' := 'TIID^Device 1 (EtherCAT)^Term 4 (EK1200)^di^Channel 1^Input'}		
    	sto AT %I*: BOOL;
    	
    	
    	fbMotionStage_m_pi  :FB_MotionStage;
    	fbMotionStage_g_pi  :FB_MotionStage;
    	fbMotionStage_m_h   :FB_MotionStage;
    	fbMotionStage_g_h   :FB_MotionStage;
    	fbMotionStage_s_r   :FB_MotionStage;
    	fbMotionStage_s_io  :FB_MotionStage;
    	
    	

    	
    	
    	gpi_enable :BOOL;
    	mpi_enable :BOOL;
    	gh_enable :BOOL;
    	mh_enable :BOOL;
    	sio_enable :BOOL;
    	sr_enable :BOOL;
    	
    	
    	{attribute 'TcLinkTo' := '.Count:=TIIB[m_pi_up_dwn_e]^FB Inputs Channel 1^Position'}	
    	mpi_upe  AT %I*:  ST_RenishawAbsEnc:=(ref:=0);
    	{attribute 'TcLinkTo' := '.Count:=TIIB[g_pi_up_dwn_e]^FB Inputs Channel 1^Position'}
    	gpi_upe  AT %I*:  ST_RenishawAbsEnc:=(ref:=0);

    	{attribute 'pytmc' := '
    		pv: SP1K1:MONO:ENC:M_PI:02
    		io: o
    	'}
    	mpi_upeurad: LREAL;
    	{attribute 'pytmc' := '
    		pv:SP1K1:MONO:ENC:G_PI:02
    		io: o
    	'}
    	gpi_upeurad: LREAL;
    	
    	
    	(*Flow Switches*)
    	{attribute 'TcLinkTo' := 'TIID^Device 4 (EtherCAT)^GM^Term 16 (EL3054)^AI Standard Channel 1^Value'}	
    	flow_1 AT %I*: INT;
    	{attribute 'TcLinkTo' := 'TIID^Device 4 (EtherCAT)^GM^Term 16 (EL3054)^AI Standard Channel 2^Value'}	
    	flow_2 AT %I*: INT;
    	{attribute 'TcLinkTo' := 'TIID^Device 4 (EtherCAT)^GM^Term 16 (EL3054)^AI Standard Channel 3^Value'}		
    	pres_1 AT %I*: INT;
    		
    	{attribute 'pytmc' := '
    		pv:  SP1K1:MONO:FSW:01
    		io: o
    	'}
    	FLOW1 : LREAL := 0.00;
    	
    	{attribute 'pytmc' := '
    		pv:  SP1K1:MONO:FSW:02
    		io: o
    	'}
    	FLOW2 : LREAL := 0.00;
    	
    	{attribute 'pytmc' := '
    		pv:  SP1K1:MONO:P1
    		io: o
    	'}
    	PRES1 : LREAL := 0.00;


    	(*RTDs*)
    	{attribute 'pytmc' := '
    		pv: SP1K1:MONO:RTD:01
    		io: o
    	'}
    	 {attribute 'TcLinkTo' := '.iRaw := TIIB[SP1K1-EL3202-E13]^RTD Inputs Channel 1^Value;
                                  .bError := TIIB[SP1K1-EL3202-E13]^RTD Inputs Channel 1^Status^Error;
                                  .bUnderrange := TIIBSP1K1-EL3202-E13]^RTD Inputs Channel 1^Status^Underrange;
                                  .bOverrange := TIIB[SP1K1-EL3202-E13]^RTD Inputs Channel 1^Status^Overrange'}
    	RTD1 : FB_TempSensor;
    	
    	{attribute 'pytmc' := '
    		pv: SP1K1:MONO:RTD:02
    		io: o
    	'}
    	{attribute 'TcLinkTo' := '.iRaw := TIIB[SP1K1-EL3202-E13]^RTD Inputs Channel 2^Value;
                                  .bError := TIIB[SP1K1-EL3202-E13]^RTD Inputs Channel 2^Status^Error;
                                  .bUnderrange := TIIBSP1K1-EL3202-E13]^RTD Inputs Channel 2^Status^Underrange;
                                  .bOverrange := TIIB[SP1K1-EL3202-E13]^RTD Inputs Channel 2^Status^Overrange'}
    	RTD2 : FB_TempSensor;
    	
    	{attribute 'pytmc' := '
    		pv: SP1K1:MONO:RTD:03
    		io: o
    	'}
    	 {attribute 'TcLinkTo' := '.iRaw := TIIB[SP1K1-EL3202-E14]^RTD Inputs Channel 1^Value;
                                  .bError := TIIB[SP1K1-EL3202-E14]^RTD Inputs Channel 1^Status^Error;
                                  .bUnderrange := TIIBSP1K1-EL3202-E14]^RTD Inputs Channel 1^Status^Underrange;
                                  .bOverrange := TIIB[SP1K1-EL3202-E14]^RTD Inputs Channel 1^Status^Overrange'}
    	RTD3 :FB_TempSensor;
    	
    	{attribute 'pytmc' := '
    		pv: SP1K1:MONO:RTD:04
    		io: o
    	'}
    	{attribute 'TcLinkTo' := '.iRaw := TIIB[SP1K1-EL3202-E14]^RTD Inputs Channel 2^Value;
                                  .bError := TIIB[SP1K1-EL3202-E14]^RTD Inputs Channel 2^Status^Error;
                                  .bUnderrange := TIIBSP1K1-EL3202-E14]^RTD Inputs Channel 2^Status^Underrange;
                                  .bOverrange := TIIB[SP1K1-EL3202-E14]^RTD Inputs Channel 2^Status^Overrange'}
    	RTD4 : FB_TempSensor;
    	
    		{attribute 'pytmc' := '
    		pv: SP1K1:MONO:RTD:05
    		io: o
    	'}
    	{attribute 'TcLinkTo' := '.iRaw := TIIB[SP1K1-EL3202-E15]^RTD Inputs Channel 1^Value;
                                  .bError := TIIB[SP1K1-EL3202-E15]^RTD Inputs Channel 1^Status^Error;
                                  .bUnderrange := TIIBSP1K1-EL3202-E15]^RTD Inputs Channel 1^Status^Underrange;
                                  .bOverrange := TIIB[SP1K1-EL3202-E15]^RTD Inputs Channel 1^Status^Overrange'}
    	RTD5 : FB_TempSensor;
    	
    	{attribute 'pytmc' := '
    		pv: SP1K1:MONO:RTD:06
    		io: o
    	'}
    	{attribute 'TcLinkTo' := '.iRaw := TIIB[SP1K1-EL3202-E15]^RTD Inputs Channel 2^Value;
                                  .bError := TIIB[SP1K1-EL3202-E15]^RTD Inputs Channel 2^Status^Error;
                                  .bUnderrange := TIIBSP1K1-EL3202-E15]^RTD Inputs Channel 2^Status^Underrange;
                                  .bOverrange := TIIB[SP1K1-EL3202-E15]^RTD Inputs Channel 2^Status^Overrange'}
    	RTD6 : FB_TempSensor;
    	
    	{attribute 'pytmc' := '
    		pv: SP1K1:MONO:RTD:07
    		io: o
    	'}
    	{attribute 'TcLinkTo' := '.iRaw := TIIB[SP1K1-EL3202-E16]^RTD Inputs Channel 1^Value;
                                  .bError := TIIB[SP1K1-EL3202-E16]^RTD Inputs Channel 1^Status^Error;
                                  .bUnderrange := TIIBSP1K1-EL3202-E16]^RTD Inputs Channel 1^Status^Underrange;
                                  .bOverrange := TIIB[SP1K1-EL3202-E16]^RTD Inputs Channel 1^Status^Overrange'}
    	RTD7 : FB_TempSensor;
    	
    	{attribute 'pytmc' := '
    		pv: SP1K1:MONO:RTD:08
    		io: o
    	'}
    	{attribute 'TcLinkTo' := '.iRaw := TIIB[SP1K1-EL3202-E16]^RTD Inputs Channel 2^Value;
                                  .bError := TIIB[SP1K1-EL3202-E16]^RTD Inputs Channel 2^Status^Error;
                                  .bUnderrange := TIIBSP1K1-EL3202-E16]^RTD Inputs Channel 2^Status^Underrange;
                                  .bOverrange := TIIB[SP1K1-EL3202-E16]^RTD Inputs Channel 2^Status^Overrange'}
    	RTD8 :FB_TempSensor;
    	
    	
    	
    	
    	
    	//////////TODO
    	
    	{attribute 'pytmc' := '
    		pv: GM:PITCH:fipi_read
    		io: i
    	'}	
    	fipi_read: LREAL;
    	
    	{attribute 'pytmc' := '
    		pv: GM:PITCH:fipi_set
    		io: o
    	'}
    	fipi_set:  LREAL;
    	
    	
    	dx: LREAL;
    	dy: LREAL;	

    	{attribute 'pytmc' := '
       	pv: GM:m:pi:EnableMode
       	io: io
    	'}
    	bmpiEpicsEnable : BOOL;
    	
    	{attribute 'pytmc' := '
       	pv: GM:g:pi:EnableMode
       	io: io
    	'}
    	bgpiEpicsEnable : BOOL;
    	
    	
    	{attribute 'pytmc' := '
       	pv: GM:m:h:EnableMode
       	io: io
    	'}
    	bmhEpicsEnable : BOOL;
    	
    	{attribute 'pytmc' := '
       	pv: GM:g:h:EnableMode
       	io: io
    	'}
    	bghEpicsEnable : BOOL;
    	
    	{attribute 'pytmc' := '
       	pv: GM:s:io:EnableMode
       	io: io
    	'}
    	bsioEpicsEnable : BOOL;
    	
    	{attribute 'pytmc' := '
       	pv: GM:s:r:EnableMode
       	io: io
    	'}
    	bsrEpicsEnable : BOOL;
    	
    	//
    	bTest: BOOL := FALSE;
    	mv_mpi: MC_MoveAbsolute;	
    	mv_gpi: MC_MoveAbsolute;
    	mv_mh: MC_MoveAbsolute;	
    	mv_gh: MC_MoveAbsolute;	
    	mv_sio: MC_MoveAbsolute;	
    	mv_sr: MC_MoveAbsolute;	
    		gpi_start: BOOL;
    	gpi_position: LREAL;
    	gpi_velocity: LREAL := 200;

    	
    	mpi_start: BOOL;
    	mpi_position: LREAL;
    	mpi_velocity: LREAL := 200;


    	gh_start: BOOL;
    	gh_position: LREAL;
    	gh_velocity: LREAL := 1000;
    	
    	mh_start: BOOL;
    	mh_position: LREAL;
    	mh_velocity: LREAL := 500;
    	
    	sio_start: BOOL;
    	sio_position: LREAL;
    	sio_velocity: LREAL := 500;
    	
    	sr_start: BOOL;
    	sr_position: LREAL;
    	sr_velocity: LREAL := 500;
    	//

    	
    END_VAR
    M6.bHardwareEnable := sto AND mpi_enable;
    M7.bHardwareEnable := sto AND gpi_enable;
    M8.bHardwareEnable := sto AND mh_enable; 
    M9.bHardwareEnable := sto AND gh_enable;
    M10.bHardwareEnable := sto AND sio_enable;
    M11.bHardwareEnable := sto AND sr_enable;

    (*
    M6.bPowerSelf :=TRUE;
    M7.bPowerSelf :=TRUE;
    M8.bPowerSelf :=TRUE;
    M9.bPowerSelf :=TRUE;
    M10.bPowerSelf :=TRUE;
    M11.bPowerSelf :=TRUE;
    *)


    // Let bM1EpicsEnable control axis enable/disable
    mpi_enable := bmpiEpicsEnable;
    gpi_enable := bgpiEpicsEnable;
    mh_enable  := bmhEpicsEnable;
    gh_enable  := bghEpicsEnable;
    sio_enable  := bsioEpicsEnable;
    sr_enable  := bsrEpicsEnable;

    fbMotionStage_m_pi  (stMotionStage:=M6);
    fbMotionStage_g_pi  (stMotionStage:=M7);
    fbMotionStage_m_h  (stMotionStage:=M8);
    fbMotionStage_g_h  (stMotionStage:=M9);
    fbMotionStage_s_io  (stMotionStage:=M10);
    fbMotionStage_s_r  (stMotionStage:=M11);
    //S_R with no hardware limit switched
    M11.bAllBackwardEnable := TRUE;
    M11.bLimitForwardEnable := TRUE;

    mpi_upeurad := ULINT_TO_LREAL(mpi_upe.Count)*0.004505;
    gpi_upeurad := ULINT_TO_LREAL(gpi_upe.Count)*0.0066667;



    (*Flow Switches and RTDs*)
    FLOW1 := INT_TO_LREAL(flow_1)/32767*4;
    FLOW2 := INT_TO_LREAL(flow_2)/32767*4;
    PRES1 := INT_TO_LREAL(pres_1)/32767*2;
    RTD1();
    RTD2();
    RTD3();
    RTD4();
    RTD5();
    RTD6();
    RTD7();
    RTD8();


    IF (bTest) THEN
    	mv_mpi(axis:=M6.Axis, execute:=mpi_start, position:=mpi_position, velocity:=mpi_velocity);
    	mv_gpi(axis:=M7.Axis, execute:=gpi_start, position:=gpi_position, velocity:=gpi_velocity);
    	mv_mh(axis:=M8.Axis, execute:=mh_start, position:=mh_position, velocity:=mh_velocity);
    	mv_gh(axis:=M9.Axis, execute:=gh_start, position:=gh_position, velocity:=gh_velocity);
    	mv_sio(axis:=M10.Axis, execute:=sio_start, position:=sio_position, velocity:=sio_velocity);
    	mv_sr(axis:=M11.Axis, execute:=sr_start, position:=sr_position, velocity:=sr_velocity);	
    END_IF

    END_PROGRAM

